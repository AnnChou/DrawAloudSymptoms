// Fabric.js Setup
const canvas = new fabric.Canvas('drawing');
canvas.isDrawingMode = true;
canvas.freeDrawingBrush.color = document.getElementById("brushColor").value;
canvas.freeDrawingBrush.width = 2;

const PROMPTS = [
  { id: "grounding", label: "Grounding (pause, no drawing)", snomed: "28770003" },
  { id: "landmark1", label: "First Health Landmark – Recall Feeling", snomed: "225444004" },
  { id: "landmark2", label: "Second Health Landmark – Current Feeling", snomed: "289908002" },
  { id: "optimal", label: "Optimal State – What I Wish For", snomed: "225358003" }
];

let currentPromptIndex = 0;
const strokeData = [];

function setPrompt(index) {
  currentPromptIndex = index;
  document.getElementById("currentPrompt").textContent = PROMPTS[index].label;
}

setPrompt(0);

canvas.on('path:created', function(opt) {
  const timestamp = new Date();
  const path = opt.path;
  path.set({ timestamp });
  strokeData.push({
    time: timestamp,
    label: PROMPTS[currentPromptIndex].label,
    promptId: PROMPTS[currentPromptIndex].id,
    snomed: PROMPTS[currentPromptIndex].snomed
  });
  updateTimeline();
});

function downloadImage() {
  const dataURL = canvas.toDataURL({ format: 'png' });
  const a = document.createElement('a');
  a.href = dataURL;
  a.download = 'drawing.png';
  a.click();
}

document.getElementById("brushColor").addEventListener("change", (e) => {
  canvas.freeDrawingBrush.color = e.target.value;
});

document.getElementById("undoBtn").addEventListener("click", () => {
  const last = canvas._objects.pop();
  canvas.requestRenderAll();
  strokeData.pop();
  updateTimeline();
});

document.getElementById("nextPromptBtn").addEventListener("click", () => {
  if (currentPromptIndex < PROMPTS.length - 1) {
    setPrompt(currentPromptIndex + 1);
  }
});

document.getElementById("prevPromptBtn").addEventListener("click", () => {
  if (currentPromptIndex > 0) {
    setPrompt(currentPromptIndex - 1);
  }
});

function exportFHIR() {
  const grouped = {};
  strokeData.forEach(d => {
    if (!grouped[d.promptId]) grouped[d.promptId] = [];
    grouped[d.promptId].push(d);
  });

  const answers = Object.entries(grouped).map(([key, strokes], i) => {
    const prompt = PROMPTS.find(p => p.id === key);
    return {
      linkId: key,
      text: prompt.label,
      answer: strokes.map(s => ({
        valueString: `Drawn at ${s.time.toISOString()}`,
        extension: [
          {
            url: "http://hl7.org/fhir/StructureDefinition/condition-code",
            valueCoding: {
              system: "http://snomed.info/sct",
              code: s.snomed,
              display: prompt.label
            }
          }
        ]
      }))
    };
  });

  const reflectionText = document.getElementById("reflectionText").value;
  if (reflectionText) {
    answers.push({
      linkId: "reflection",
      text: "Reflection Words",
      answer: [{ valueString: reflectionText }]
    });
  }

  const response = {
    resourceType: "QuestionnaireResponse",
    status: "completed",
    authored: new Date().toISOString(),
    item: answers
  };

  const blob = new Blob([JSON.stringify(response, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "questionnaire_response.json";
  a.click();
}

function updateTimeline() {
  const svg = d3.select("#timeline");
  svg.selectAll("*").remove();

  const times = strokeData.map(d => d.time);
  const width = +svg.attr("width");
  const height = +svg.attr("height");
  const margin = { top: 20, right: 20, bottom: 30, left: 40 };

  const x = d3.scaleTime()
    .domain(d3.extent(times))
    .range([margin.left, width - margin.right]);

  svg.append("g")
    .attr("transform", `translate(0,${height - margin.bottom})`)
    .call(d3.axisBottom(x).ticks(5).tickFormat(d3.timeFormat("%H:%M:%S")));

  svg.selectAll("circle")
    .data(strokeData)
    .enter()
    .append("circle")
    .attr("cx", d => x(d.time))
    .attr("cy", height / 2)
    .attr("r", 6)
    .attr("fill", d => {
      const i = PROMPTS.findIndex(p => p.id === d.promptId);
      return d3.schemeCategory10[i % 10];
    })
    .append("title")
    .text(d => `${d.label} @ ${d.time.toLocaleTimeString()}`);
}
